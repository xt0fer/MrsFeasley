// Code generated by Prisma CLI (https://github.com/prisma/prisma). DO NOT EDIT.

package prisma

import (
	"context"
	"errors"

	"github.com/prisma/prisma-client-lib-go"

	"github.com/machinebox/graphql"
)

var ErrNoResult = errors.New("query returned no result")

func Str(v string) *string { return &v }
func Int32(v int32) *int32 { return &v }
func Bool(v bool) *bool    { return &v }

type BatchPayloadExec struct {
	exec *prisma.BatchPayloadExec
}

func (exec *BatchPayloadExec) Exec(ctx context.Context) (BatchPayload, error) {
	bp, err := exec.exec.Exec(ctx)
	return BatchPayload(bp), err
}

type BatchPayload struct {
	Count int64 `json:"count"`
}

type Aggregate struct {
	Count int64 `json:"count"`
}

type Client struct {
	Client *prisma.Client
}

type Options struct {
	Endpoint string
	Secret   string
}

func New(options *Options, opts ...graphql.ClientOption) *Client {
	endpoint := DefaultEndpoint
	secret := Secret
	if options != nil {
		endpoint = options.Endpoint
		secret = options.Secret
	}
	return &Client{
		Client: prisma.New(endpoint, secret, opts...),
	}
}

func (client *Client) GraphQL(ctx context.Context, query string, variables map[string]interface{}) (map[string]interface{}, error) {
	return client.Client.GraphQL(ctx, query, variables)
}

var DefaultEndpoint = "http://localhost:4467"
var Secret = ""

func (client *Client) Note(params NoteWhereUniqueInput) *NoteExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"NoteWhereUniqueInput!", "Note"},
		"note",
		[]string{"id", "title", "body"})

	return &NoteExec{ret}
}

type NotesParams struct {
	Where   *NoteWhereInput   `json:"where,omitempty"`
	OrderBy *NoteOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) Notes(params *NotesParams) *NoteExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"NoteWhereInput", "NoteOrderByInput", "Note"},
		"notes",
		[]string{"id", "title", "body"})

	return &NoteExecArray{ret}
}

type NotesConnectionParams struct {
	Where   *NoteWhereInput   `json:"where,omitempty"`
	OrderBy *NoteOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) NotesConnection(params *NotesConnectionParams) NoteConnectionExec {
	panic("not implemented")
}

func (client *Client) Tag(params TagWhereUniqueInput) *TagExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"TagWhereUniqueInput!", "Tag"},
		"tag",
		[]string{"id", "title"})

	return &TagExec{ret}
}

type TagsParams struct {
	Where   *TagWhereInput   `json:"where,omitempty"`
	OrderBy *TagOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32           `json:"skip,omitempty"`
	After   *string          `json:"after,omitempty"`
	Before  *string          `json:"before,omitempty"`
	First   *int32           `json:"first,omitempty"`
	Last    *int32           `json:"last,omitempty"`
}

func (client *Client) Tags(params *TagsParams) *TagExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"TagWhereInput", "TagOrderByInput", "Tag"},
		"tags",
		[]string{"id", "title"})

	return &TagExecArray{ret}
}

type TagsConnectionParams struct {
	Where   *TagWhereInput   `json:"where,omitempty"`
	OrderBy *TagOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32           `json:"skip,omitempty"`
	After   *string          `json:"after,omitempty"`
	Before  *string          `json:"before,omitempty"`
	First   *int32           `json:"first,omitempty"`
	Last    *int32           `json:"last,omitempty"`
}

func (client *Client) TagsConnection(params *TagsConnectionParams) TagConnectionExec {
	panic("not implemented")
}

func (client *Client) User(params UserWhereUniqueInput) *UserExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"UserWhereUniqueInput!", "User"},
		"user",
		[]string{"id", "name"})

	return &UserExec{ret}
}

type UsersParams struct {
	Where   *UserWhereInput   `json:"where,omitempty"`
	OrderBy *UserOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) Users(params *UsersParams) *UserExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"UserWhereInput", "UserOrderByInput", "User"},
		"users",
		[]string{"id", "name"})

	return &UserExecArray{ret}
}

type UsersConnectionParams struct {
	Where   *UserWhereInput   `json:"where,omitempty"`
	OrderBy *UserOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) UsersConnection(params *UsersConnectionParams) UserConnectionExec {
	panic("not implemented")
}

func (client *Client) CreateNote(params NoteCreateInput) *NoteExec {
	ret := client.Client.Create(
		params,
		[2]string{"NoteCreateInput!", "Note"},
		"createNote",
		[]string{"id", "title", "body"})

	return &NoteExec{ret}
}

type NoteUpdateParams struct {
	Data  NoteUpdateInput      `json:"data"`
	Where NoteWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateNote(params NoteUpdateParams) *NoteExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"NoteUpdateInput!", "NoteWhereUniqueInput!", "Note"},
		"updateNote",
		[]string{"id", "title", "body"})

	return &NoteExec{ret}
}

type NoteUpdateManyParams struct {
	Data  NoteUpdateManyMutationInput `json:"data"`
	Where *NoteWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyNotes(params NoteUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"NoteUpdateManyMutationInput!", "NoteWhereInput"},
		"updateManyNotes")
	return &BatchPayloadExec{exec}
}

type NoteUpsertParams struct {
	Where  NoteWhereUniqueInput `json:"where"`
	Create NoteCreateInput      `json:"create"`
	Update NoteUpdateInput      `json:"update"`
}

func (client *Client) UpsertNote(params NoteUpsertParams) *NoteExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"NoteWhereUniqueInput!", "NoteCreateInput!", "NoteUpdateInput!", "Note"},
		"upsertNote",
		[]string{"id", "title", "body"})

	return &NoteExec{ret}
}

func (client *Client) DeleteNote(params NoteWhereUniqueInput) *NoteExec {
	ret := client.Client.Delete(
		params,
		[2]string{"NoteWhereUniqueInput!", "Note"},
		"deleteNote",
		[]string{"id", "title", "body"})

	return &NoteExec{ret}
}

func (client *Client) DeleteManyNotes(params *NoteWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "NoteWhereInput", "deleteManyNotes")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateTag(params TagCreateInput) *TagExec {
	ret := client.Client.Create(
		params,
		[2]string{"TagCreateInput!", "Tag"},
		"createTag",
		[]string{"id", "title"})

	return &TagExec{ret}
}

type TagUpdateParams struct {
	Data  TagUpdateInput      `json:"data"`
	Where TagWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateTag(params TagUpdateParams) *TagExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"TagUpdateInput!", "TagWhereUniqueInput!", "Tag"},
		"updateTag",
		[]string{"id", "title"})

	return &TagExec{ret}
}

type TagUpdateManyParams struct {
	Data  TagUpdateManyMutationInput `json:"data"`
	Where *TagWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyTags(params TagUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"TagUpdateManyMutationInput!", "TagWhereInput"},
		"updateManyTags")
	return &BatchPayloadExec{exec}
}

type TagUpsertParams struct {
	Where  TagWhereUniqueInput `json:"where"`
	Create TagCreateInput      `json:"create"`
	Update TagUpdateInput      `json:"update"`
}

func (client *Client) UpsertTag(params TagUpsertParams) *TagExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"TagWhereUniqueInput!", "TagCreateInput!", "TagUpdateInput!", "Tag"},
		"upsertTag",
		[]string{"id", "title"})

	return &TagExec{ret}
}

func (client *Client) DeleteTag(params TagWhereUniqueInput) *TagExec {
	ret := client.Client.Delete(
		params,
		[2]string{"TagWhereUniqueInput!", "Tag"},
		"deleteTag",
		[]string{"id", "title"})

	return &TagExec{ret}
}

func (client *Client) DeleteManyTags(params *TagWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "TagWhereInput", "deleteManyTags")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateUser(params UserCreateInput) *UserExec {
	ret := client.Client.Create(
		params,
		[2]string{"UserCreateInput!", "User"},
		"createUser",
		[]string{"id", "name"})

	return &UserExec{ret}
}

type UserUpdateParams struct {
	Data  UserUpdateInput      `json:"data"`
	Where UserWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateUser(params UserUpdateParams) *UserExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"UserUpdateInput!", "UserWhereUniqueInput!", "User"},
		"updateUser",
		[]string{"id", "name"})

	return &UserExec{ret}
}

type UserUpdateManyParams struct {
	Data  UserUpdateManyMutationInput `json:"data"`
	Where *UserWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyUsers(params UserUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"UserUpdateManyMutationInput!", "UserWhereInput"},
		"updateManyUsers")
	return &BatchPayloadExec{exec}
}

type UserUpsertParams struct {
	Where  UserWhereUniqueInput `json:"where"`
	Create UserCreateInput      `json:"create"`
	Update UserUpdateInput      `json:"update"`
}

func (client *Client) UpsertUser(params UserUpsertParams) *UserExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"UserWhereUniqueInput!", "UserCreateInput!", "UserUpdateInput!", "User"},
		"upsertUser",
		[]string{"id", "name"})

	return &UserExec{ret}
}

func (client *Client) DeleteUser(params UserWhereUniqueInput) *UserExec {
	ret := client.Client.Delete(
		params,
		[2]string{"UserWhereUniqueInput!", "User"},
		"deleteUser",
		[]string{"id", "name"})

	return &UserExec{ret}
}

func (client *Client) DeleteManyUsers(params *UserWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "UserWhereInput", "deleteManyUsers")
	return &BatchPayloadExec{exec}
}

type TagOrderByInput string

const (
	TagOrderByInputIDAsc         TagOrderByInput = "id_ASC"
	TagOrderByInputIDDesc        TagOrderByInput = "id_DESC"
	TagOrderByInputTitleAsc      TagOrderByInput = "title_ASC"
	TagOrderByInputTitleDesc     TagOrderByInput = "title_DESC"
	TagOrderByInputCreatedAtAsc  TagOrderByInput = "createdAt_ASC"
	TagOrderByInputCreatedAtDesc TagOrderByInput = "createdAt_DESC"
	TagOrderByInputUpdatedAtAsc  TagOrderByInput = "updatedAt_ASC"
	TagOrderByInputUpdatedAtDesc TagOrderByInput = "updatedAt_DESC"
)

type NoteOrderByInput string

const (
	NoteOrderByInputIDAsc         NoteOrderByInput = "id_ASC"
	NoteOrderByInputIDDesc        NoteOrderByInput = "id_DESC"
	NoteOrderByInputTitleAsc      NoteOrderByInput = "title_ASC"
	NoteOrderByInputTitleDesc     NoteOrderByInput = "title_DESC"
	NoteOrderByInputBodyAsc       NoteOrderByInput = "body_ASC"
	NoteOrderByInputBodyDesc      NoteOrderByInput = "body_DESC"
	NoteOrderByInputCreatedAtAsc  NoteOrderByInput = "createdAt_ASC"
	NoteOrderByInputCreatedAtDesc NoteOrderByInput = "createdAt_DESC"
	NoteOrderByInputUpdatedAtAsc  NoteOrderByInput = "updatedAt_ASC"
	NoteOrderByInputUpdatedAtDesc NoteOrderByInput = "updatedAt_DESC"
)

type UserOrderByInput string

const (
	UserOrderByInputIDAsc         UserOrderByInput = "id_ASC"
	UserOrderByInputIDDesc        UserOrderByInput = "id_DESC"
	UserOrderByInputNameAsc       UserOrderByInput = "name_ASC"
	UserOrderByInputNameDesc      UserOrderByInput = "name_DESC"
	UserOrderByInputCreatedAtAsc  UserOrderByInput = "createdAt_ASC"
	UserOrderByInputCreatedAtDesc UserOrderByInput = "createdAt_DESC"
	UserOrderByInputUpdatedAtAsc  UserOrderByInput = "updatedAt_ASC"
	UserOrderByInputUpdatedAtDesc UserOrderByInput = "updatedAt_DESC"
)

type MutationType string

const (
	MutationTypeCreated MutationType = "CREATED"
	MutationTypeUpdated MutationType = "UPDATED"
	MutationTypeDeleted MutationType = "DELETED"
)

type TagUpdateWithoutNotesDataInput struct {
	Title *string `json:"title,omitempty"`
}

type NoteWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type TagUpdateManyWithWhereNestedInput struct {
	Where TagScalarWhereInput    `json:"where"`
	Data  TagUpdateManyDataInput `json:"data"`
}

type NoteWhereInput struct {
	ID                 *string          `json:"id,omitempty"`
	IDNot              *string          `json:"id_not,omitempty"`
	IDIn               []string         `json:"id_in,omitempty"`
	IDNotIn            []string         `json:"id_not_in,omitempty"`
	IDLt               *string          `json:"id_lt,omitempty"`
	IDLte              *string          `json:"id_lte,omitempty"`
	IDGt               *string          `json:"id_gt,omitempty"`
	IDGte              *string          `json:"id_gte,omitempty"`
	IDContains         *string          `json:"id_contains,omitempty"`
	IDNotContains      *string          `json:"id_not_contains,omitempty"`
	IDStartsWith       *string          `json:"id_starts_with,omitempty"`
	IDNotStartsWith    *string          `json:"id_not_starts_with,omitempty"`
	IDEndsWith         *string          `json:"id_ends_with,omitempty"`
	IDNotEndsWith      *string          `json:"id_not_ends_with,omitempty"`
	Title              *string          `json:"title,omitempty"`
	TitleNot           *string          `json:"title_not,omitempty"`
	TitleIn            []string         `json:"title_in,omitempty"`
	TitleNotIn         []string         `json:"title_not_in,omitempty"`
	TitleLt            *string          `json:"title_lt,omitempty"`
	TitleLte           *string          `json:"title_lte,omitempty"`
	TitleGt            *string          `json:"title_gt,omitempty"`
	TitleGte           *string          `json:"title_gte,omitempty"`
	TitleContains      *string          `json:"title_contains,omitempty"`
	TitleNotContains   *string          `json:"title_not_contains,omitempty"`
	TitleStartsWith    *string          `json:"title_starts_with,omitempty"`
	TitleNotStartsWith *string          `json:"title_not_starts_with,omitempty"`
	TitleEndsWith      *string          `json:"title_ends_with,omitempty"`
	TitleNotEndsWith   *string          `json:"title_not_ends_with,omitempty"`
	Body               *string          `json:"body,omitempty"`
	BodyNot            *string          `json:"body_not,omitempty"`
	BodyIn             []string         `json:"body_in,omitempty"`
	BodyNotIn          []string         `json:"body_not_in,omitempty"`
	BodyLt             *string          `json:"body_lt,omitempty"`
	BodyLte            *string          `json:"body_lte,omitempty"`
	BodyGt             *string          `json:"body_gt,omitempty"`
	BodyGte            *string          `json:"body_gte,omitempty"`
	BodyContains       *string          `json:"body_contains,omitempty"`
	BodyNotContains    *string          `json:"body_not_contains,omitempty"`
	BodyStartsWith     *string          `json:"body_starts_with,omitempty"`
	BodyNotStartsWith  *string          `json:"body_not_starts_with,omitempty"`
	BodyEndsWith       *string          `json:"body_ends_with,omitempty"`
	BodyNotEndsWith    *string          `json:"body_not_ends_with,omitempty"`
	TagsEvery          *TagWhereInput   `json:"tags_every,omitempty"`
	TagsSome           *TagWhereInput   `json:"tags_some,omitempty"`
	TagsNone           *TagWhereInput   `json:"tags_none,omitempty"`
	And                []NoteWhereInput `json:"AND,omitempty"`
	Or                 []NoteWhereInput `json:"OR,omitempty"`
	Not                []NoteWhereInput `json:"NOT,omitempty"`
}

type NoteUpdateWithWhereUniqueWithoutTagsInput struct {
	Where NoteWhereUniqueInput           `json:"where"`
	Data  NoteUpdateWithoutTagsDataInput `json:"data"`
}

type TagCreateInput struct {
	Title string                          `json:"title"`
	Notes *NoteCreateManyWithoutTagsInput `json:"notes,omitempty"`
}

type TagUpdateManyDataInput struct {
	Title *string `json:"title,omitempty"`
}

type TagSubscriptionWhereInput struct {
	MutationIn                 []MutationType              `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                     `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                    `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                    `json:"updatedFields_contains_some,omitempty"`
	Node                       *TagWhereInput              `json:"node,omitempty"`
	And                        []TagSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []TagSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []TagSubscriptionWhereInput `json:"NOT,omitempty"`
}

type NoteCreateInput struct {
	Title string                          `json:"title"`
	Body  string                          `json:"body"`
	Tags  *TagCreateManyWithoutNotesInput `json:"tags,omitempty"`
}

type UserUpdateManyMutationInput struct {
	Name *string `json:"name,omitempty"`
}

type TagCreateManyWithoutNotesInput struct {
	Create  []TagCreateWithoutNotesInput `json:"create,omitempty"`
	Connect []TagWhereUniqueInput        `json:"connect,omitempty"`
}

type TagWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type TagCreateWithoutNotesInput struct {
	Title string `json:"title"`
}

type TagUpdateManyMutationInput struct {
	Title *string `json:"title,omitempty"`
}

type NoteUpdateInput struct {
	Title *string                         `json:"title,omitempty"`
	Body  *string                         `json:"body,omitempty"`
	Tags  *TagUpdateManyWithoutNotesInput `json:"tags,omitempty"`
}

type UserWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type TagUpdateManyWithoutNotesInput struct {
	Create     []TagCreateWithoutNotesInput                `json:"create,omitempty"`
	Delete     []TagWhereUniqueInput                       `json:"delete,omitempty"`
	Connect    []TagWhereUniqueInput                       `json:"connect,omitempty"`
	Set        []TagWhereUniqueInput                       `json:"set,omitempty"`
	Disconnect []TagWhereUniqueInput                       `json:"disconnect,omitempty"`
	Update     []TagUpdateWithWhereUniqueWithoutNotesInput `json:"update,omitempty"`
	Upsert     []TagUpsertWithWhereUniqueWithoutNotesInput `json:"upsert,omitempty"`
	DeleteMany []TagScalarWhereInput                       `json:"deleteMany,omitempty"`
	UpdateMany []TagUpdateManyWithWhereNestedInput         `json:"updateMany,omitempty"`
}

type UserWhereInput struct {
	ID                *string          `json:"id,omitempty"`
	IDNot             *string          `json:"id_not,omitempty"`
	IDIn              []string         `json:"id_in,omitempty"`
	IDNotIn           []string         `json:"id_not_in,omitempty"`
	IDLt              *string          `json:"id_lt,omitempty"`
	IDLte             *string          `json:"id_lte,omitempty"`
	IDGt              *string          `json:"id_gt,omitempty"`
	IDGte             *string          `json:"id_gte,omitempty"`
	IDContains        *string          `json:"id_contains,omitempty"`
	IDNotContains     *string          `json:"id_not_contains,omitempty"`
	IDStartsWith      *string          `json:"id_starts_with,omitempty"`
	IDNotStartsWith   *string          `json:"id_not_starts_with,omitempty"`
	IDEndsWith        *string          `json:"id_ends_with,omitempty"`
	IDNotEndsWith     *string          `json:"id_not_ends_with,omitempty"`
	Name              *string          `json:"name,omitempty"`
	NameNot           *string          `json:"name_not,omitempty"`
	NameIn            []string         `json:"name_in,omitempty"`
	NameNotIn         []string         `json:"name_not_in,omitempty"`
	NameLt            *string          `json:"name_lt,omitempty"`
	NameLte           *string          `json:"name_lte,omitempty"`
	NameGt            *string          `json:"name_gt,omitempty"`
	NameGte           *string          `json:"name_gte,omitempty"`
	NameContains      *string          `json:"name_contains,omitempty"`
	NameNotContains   *string          `json:"name_not_contains,omitempty"`
	NameStartsWith    *string          `json:"name_starts_with,omitempty"`
	NameNotStartsWith *string          `json:"name_not_starts_with,omitempty"`
	NameEndsWith      *string          `json:"name_ends_with,omitempty"`
	NameNotEndsWith   *string          `json:"name_not_ends_with,omitempty"`
	And               []UserWhereInput `json:"AND,omitempty"`
	Or                []UserWhereInput `json:"OR,omitempty"`
	Not               []UserWhereInput `json:"NOT,omitempty"`
}

type TagUpdateWithWhereUniqueWithoutNotesInput struct {
	Where TagWhereUniqueInput            `json:"where"`
	Data  TagUpdateWithoutNotesDataInput `json:"data"`
}

type NoteUpsertWithWhereUniqueWithoutTagsInput struct {
	Where  NoteWhereUniqueInput           `json:"where"`
	Update NoteUpdateWithoutTagsDataInput `json:"update"`
	Create NoteCreateWithoutTagsInput     `json:"create"`
}

type NoteUpdateManyWithoutTagsInput struct {
	Create     []NoteCreateWithoutTagsInput                `json:"create,omitempty"`
	Delete     []NoteWhereUniqueInput                      `json:"delete,omitempty"`
	Connect    []NoteWhereUniqueInput                      `json:"connect,omitempty"`
	Set        []NoteWhereUniqueInput                      `json:"set,omitempty"`
	Disconnect []NoteWhereUniqueInput                      `json:"disconnect,omitempty"`
	Update     []NoteUpdateWithWhereUniqueWithoutTagsInput `json:"update,omitempty"`
	Upsert     []NoteUpsertWithWhereUniqueWithoutTagsInput `json:"upsert,omitempty"`
	DeleteMany []NoteScalarWhereInput                      `json:"deleteMany,omitempty"`
	UpdateMany []NoteUpdateManyWithWhereNestedInput        `json:"updateMany,omitempty"`
}

type UserSubscriptionWhereInput struct {
	MutationIn                 []MutationType               `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                      `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                     `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                     `json:"updatedFields_contains_some,omitempty"`
	Node                       *UserWhereInput              `json:"node,omitempty"`
	And                        []UserSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []UserSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []UserSubscriptionWhereInput `json:"NOT,omitempty"`
}

type TagUpsertWithWhereUniqueWithoutNotesInput struct {
	Where  TagWhereUniqueInput            `json:"where"`
	Update TagUpdateWithoutNotesDataInput `json:"update"`
	Create TagCreateWithoutNotesInput     `json:"create"`
}

type UserUpdateInput struct {
	Name *string `json:"name,omitempty"`
}

type TagScalarWhereInput struct {
	ID                 *string               `json:"id,omitempty"`
	IDNot              *string               `json:"id_not,omitempty"`
	IDIn               []string              `json:"id_in,omitempty"`
	IDNotIn            []string              `json:"id_not_in,omitempty"`
	IDLt               *string               `json:"id_lt,omitempty"`
	IDLte              *string               `json:"id_lte,omitempty"`
	IDGt               *string               `json:"id_gt,omitempty"`
	IDGte              *string               `json:"id_gte,omitempty"`
	IDContains         *string               `json:"id_contains,omitempty"`
	IDNotContains      *string               `json:"id_not_contains,omitempty"`
	IDStartsWith       *string               `json:"id_starts_with,omitempty"`
	IDNotStartsWith    *string               `json:"id_not_starts_with,omitempty"`
	IDEndsWith         *string               `json:"id_ends_with,omitempty"`
	IDNotEndsWith      *string               `json:"id_not_ends_with,omitempty"`
	Title              *string               `json:"title,omitempty"`
	TitleNot           *string               `json:"title_not,omitempty"`
	TitleIn            []string              `json:"title_in,omitempty"`
	TitleNotIn         []string              `json:"title_not_in,omitempty"`
	TitleLt            *string               `json:"title_lt,omitempty"`
	TitleLte           *string               `json:"title_lte,omitempty"`
	TitleGt            *string               `json:"title_gt,omitempty"`
	TitleGte           *string               `json:"title_gte,omitempty"`
	TitleContains      *string               `json:"title_contains,omitempty"`
	TitleNotContains   *string               `json:"title_not_contains,omitempty"`
	TitleStartsWith    *string               `json:"title_starts_with,omitempty"`
	TitleNotStartsWith *string               `json:"title_not_starts_with,omitempty"`
	TitleEndsWith      *string               `json:"title_ends_with,omitempty"`
	TitleNotEndsWith   *string               `json:"title_not_ends_with,omitempty"`
	And                []TagScalarWhereInput `json:"AND,omitempty"`
	Or                 []TagScalarWhereInput `json:"OR,omitempty"`
	Not                []TagScalarWhereInput `json:"NOT,omitempty"`
}

type NoteUpdateManyDataInput struct {
	Title *string `json:"title,omitempty"`
	Body  *string `json:"body,omitempty"`
}

type TagUpdateInput struct {
	Title *string                         `json:"title,omitempty"`
	Notes *NoteUpdateManyWithoutTagsInput `json:"notes,omitempty"`
}

type NoteScalarWhereInput struct {
	ID                 *string                `json:"id,omitempty"`
	IDNot              *string                `json:"id_not,omitempty"`
	IDIn               []string               `json:"id_in,omitempty"`
	IDNotIn            []string               `json:"id_not_in,omitempty"`
	IDLt               *string                `json:"id_lt,omitempty"`
	IDLte              *string                `json:"id_lte,omitempty"`
	IDGt               *string                `json:"id_gt,omitempty"`
	IDGte              *string                `json:"id_gte,omitempty"`
	IDContains         *string                `json:"id_contains,omitempty"`
	IDNotContains      *string                `json:"id_not_contains,omitempty"`
	IDStartsWith       *string                `json:"id_starts_with,omitempty"`
	IDNotStartsWith    *string                `json:"id_not_starts_with,omitempty"`
	IDEndsWith         *string                `json:"id_ends_with,omitempty"`
	IDNotEndsWith      *string                `json:"id_not_ends_with,omitempty"`
	Title              *string                `json:"title,omitempty"`
	TitleNot           *string                `json:"title_not,omitempty"`
	TitleIn            []string               `json:"title_in,omitempty"`
	TitleNotIn         []string               `json:"title_not_in,omitempty"`
	TitleLt            *string                `json:"title_lt,omitempty"`
	TitleLte           *string                `json:"title_lte,omitempty"`
	TitleGt            *string                `json:"title_gt,omitempty"`
	TitleGte           *string                `json:"title_gte,omitempty"`
	TitleContains      *string                `json:"title_contains,omitempty"`
	TitleNotContains   *string                `json:"title_not_contains,omitempty"`
	TitleStartsWith    *string                `json:"title_starts_with,omitempty"`
	TitleNotStartsWith *string                `json:"title_not_starts_with,omitempty"`
	TitleEndsWith      *string                `json:"title_ends_with,omitempty"`
	TitleNotEndsWith   *string                `json:"title_not_ends_with,omitempty"`
	Body               *string                `json:"body,omitempty"`
	BodyNot            *string                `json:"body_not,omitempty"`
	BodyIn             []string               `json:"body_in,omitempty"`
	BodyNotIn          []string               `json:"body_not_in,omitempty"`
	BodyLt             *string                `json:"body_lt,omitempty"`
	BodyLte            *string                `json:"body_lte,omitempty"`
	BodyGt             *string                `json:"body_gt,omitempty"`
	BodyGte            *string                `json:"body_gte,omitempty"`
	BodyContains       *string                `json:"body_contains,omitempty"`
	BodyNotContains    *string                `json:"body_not_contains,omitempty"`
	BodyStartsWith     *string                `json:"body_starts_with,omitempty"`
	BodyNotStartsWith  *string                `json:"body_not_starts_with,omitempty"`
	BodyEndsWith       *string                `json:"body_ends_with,omitempty"`
	BodyNotEndsWith    *string                `json:"body_not_ends_with,omitempty"`
	And                []NoteScalarWhereInput `json:"AND,omitempty"`
	Or                 []NoteScalarWhereInput `json:"OR,omitempty"`
	Not                []NoteScalarWhereInput `json:"NOT,omitempty"`
}

type NoteCreateManyWithoutTagsInput struct {
	Create  []NoteCreateWithoutTagsInput `json:"create,omitempty"`
	Connect []NoteWhereUniqueInput       `json:"connect,omitempty"`
}

type NoteCreateWithoutTagsInput struct {
	Title string `json:"title"`
	Body  string `json:"body"`
}

type NoteUpdateManyMutationInput struct {
	Title *string `json:"title,omitempty"`
	Body  *string `json:"body,omitempty"`
}

type TagWhereInput struct {
	ID                 *string         `json:"id,omitempty"`
	IDNot              *string         `json:"id_not,omitempty"`
	IDIn               []string        `json:"id_in,omitempty"`
	IDNotIn            []string        `json:"id_not_in,omitempty"`
	IDLt               *string         `json:"id_lt,omitempty"`
	IDLte              *string         `json:"id_lte,omitempty"`
	IDGt               *string         `json:"id_gt,omitempty"`
	IDGte              *string         `json:"id_gte,omitempty"`
	IDContains         *string         `json:"id_contains,omitempty"`
	IDNotContains      *string         `json:"id_not_contains,omitempty"`
	IDStartsWith       *string         `json:"id_starts_with,omitempty"`
	IDNotStartsWith    *string         `json:"id_not_starts_with,omitempty"`
	IDEndsWith         *string         `json:"id_ends_with,omitempty"`
	IDNotEndsWith      *string         `json:"id_not_ends_with,omitempty"`
	Title              *string         `json:"title,omitempty"`
	TitleNot           *string         `json:"title_not,omitempty"`
	TitleIn            []string        `json:"title_in,omitempty"`
	TitleNotIn         []string        `json:"title_not_in,omitempty"`
	TitleLt            *string         `json:"title_lt,omitempty"`
	TitleLte           *string         `json:"title_lte,omitempty"`
	TitleGt            *string         `json:"title_gt,omitempty"`
	TitleGte           *string         `json:"title_gte,omitempty"`
	TitleContains      *string         `json:"title_contains,omitempty"`
	TitleNotContains   *string         `json:"title_not_contains,omitempty"`
	TitleStartsWith    *string         `json:"title_starts_with,omitempty"`
	TitleNotStartsWith *string         `json:"title_not_starts_with,omitempty"`
	TitleEndsWith      *string         `json:"title_ends_with,omitempty"`
	TitleNotEndsWith   *string         `json:"title_not_ends_with,omitempty"`
	NotesEvery         *NoteWhereInput `json:"notes_every,omitempty"`
	NotesSome          *NoteWhereInput `json:"notes_some,omitempty"`
	NotesNone          *NoteWhereInput `json:"notes_none,omitempty"`
	And                []TagWhereInput `json:"AND,omitempty"`
	Or                 []TagWhereInput `json:"OR,omitempty"`
	Not                []TagWhereInput `json:"NOT,omitempty"`
}

type NoteUpdateWithoutTagsDataInput struct {
	Title *string `json:"title,omitempty"`
	Body  *string `json:"body,omitempty"`
}

type NoteUpdateManyWithWhereNestedInput struct {
	Where NoteScalarWhereInput    `json:"where"`
	Data  NoteUpdateManyDataInput `json:"data"`
}

type UserCreateInput struct {
	Name string `json:"name"`
}

type NoteSubscriptionWhereInput struct {
	MutationIn                 []MutationType               `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                      `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                     `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                     `json:"updatedFields_contains_some,omitempty"`
	Node                       *NoteWhereInput              `json:"node,omitempty"`
	And                        []NoteSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []NoteSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []NoteSubscriptionWhereInput `json:"NOT,omitempty"`
}

type UserPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance UserPreviousValuesExec) Exec(ctx context.Context) (*UserPreviousValues, error) {
	var v UserPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance UserPreviousValuesExecArray) Exec(ctx context.Context) ([]UserPreviousValues, error) {
	var v []UserPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type UserPreviousValues struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

type TagExec struct {
	exec *prisma.Exec
}

type NotesParamsExec struct {
	Where   *NoteWhereInput
	OrderBy *NoteOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *TagExec) Notes(params *NotesParamsExec) *NoteExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"NoteWhereInput", "NoteOrderByInput", "Note"},
		"notes",
		[]string{"id", "title", "body"})

	return &NoteExecArray{ret}
}

func (instance TagExec) Exec(ctx context.Context) (*Tag, error) {
	var v Tag
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TagExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TagExecArray struct {
	exec *prisma.Exec
}

func (instance TagExecArray) Exec(ctx context.Context) ([]Tag, error) {
	var v []Tag
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Tag struct {
	ID    string `json:"id"`
	Title string `json:"title"`
}

type TagConnectionExec struct {
	exec *prisma.Exec
}

func (instance *TagConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *TagConnectionExec) Edges() *TagEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "TagEdge"},
		"edges",
		[]string{"cursor"})

	return &TagEdgeExec{ret}
}

func (instance *TagConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateTag"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance TagConnectionExec) Exec(ctx context.Context) (*TagConnection, error) {
	var v TagConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TagConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TagConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance TagConnectionExecArray) Exec(ctx context.Context) ([]TagConnection, error) {
	var v []TagConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type TagConnection struct {
}

type TagSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *TagSubscriptionPayloadExec) Node() *TagExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Tag"},
		"node",
		[]string{"id", "title"})

	return &TagExec{ret}
}

func (instance *TagSubscriptionPayloadExec) PreviousValues() *TagPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "TagPreviousValues"},
		"previousValues",
		[]string{"id", "title"})

	return &TagPreviousValuesExec{ret}
}

func (instance TagSubscriptionPayloadExec) Exec(ctx context.Context) (*TagSubscriptionPayload, error) {
	var v TagSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TagSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TagSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance TagSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]TagSubscriptionPayload, error) {
	var v []TagSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type TagSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type NoteEdgeExec struct {
	exec *prisma.Exec
}

func (instance *NoteEdgeExec) Node() *NoteExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Note"},
		"node",
		[]string{"id", "title", "body"})

	return &NoteExec{ret}
}

func (instance NoteEdgeExec) Exec(ctx context.Context) (*NoteEdge, error) {
	var v NoteEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance NoteEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type NoteEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance NoteEdgeExecArray) Exec(ctx context.Context) ([]NoteEdge, error) {
	var v []NoteEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type NoteEdge struct {
	Cursor string `json:"cursor"`
}

type NoteConnectionExec struct {
	exec *prisma.Exec
}

func (instance *NoteConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *NoteConnectionExec) Edges() *NoteEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "NoteEdge"},
		"edges",
		[]string{"cursor"})

	return &NoteEdgeExec{ret}
}

func (instance *NoteConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateNote"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance NoteConnectionExec) Exec(ctx context.Context) (*NoteConnection, error) {
	var v NoteConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance NoteConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type NoteConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance NoteConnectionExecArray) Exec(ctx context.Context) ([]NoteConnection, error) {
	var v []NoteConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type NoteConnection struct {
}

type UserEdgeExec struct {
	exec *prisma.Exec
}

func (instance *UserEdgeExec) Node() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"node",
		[]string{"id", "name"})

	return &UserExec{ret}
}

func (instance UserEdgeExec) Exec(ctx context.Context) (*UserEdge, error) {
	var v UserEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance UserEdgeExecArray) Exec(ctx context.Context) ([]UserEdge, error) {
	var v []UserEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type UserEdge struct {
	Cursor string `json:"cursor"`
}

type TagPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance TagPreviousValuesExec) Exec(ctx context.Context) (*TagPreviousValues, error) {
	var v TagPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TagPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TagPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance TagPreviousValuesExecArray) Exec(ctx context.Context) ([]TagPreviousValues, error) {
	var v []TagPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type TagPreviousValues struct {
	ID    string `json:"id"`
	Title string `json:"title"`
}

type UserSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *UserSubscriptionPayloadExec) Node() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"node",
		[]string{"id", "name"})

	return &UserExec{ret}
}

func (instance *UserSubscriptionPayloadExec) PreviousValues() *UserPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "UserPreviousValues"},
		"previousValues",
		[]string{"id", "name"})

	return &UserPreviousValuesExec{ret}
}

func (instance UserSubscriptionPayloadExec) Exec(ctx context.Context) (*UserSubscriptionPayload, error) {
	var v UserSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance UserSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]UserSubscriptionPayload, error) {
	var v []UserSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type UserSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type PageInfoExec struct {
	exec *prisma.Exec
}

func (instance PageInfoExec) Exec(ctx context.Context) (*PageInfo, error) {
	var v PageInfo
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PageInfoExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PageInfoExecArray struct {
	exec *prisma.Exec
}

func (instance PageInfoExecArray) Exec(ctx context.Context) ([]PageInfo, error) {
	var v []PageInfo
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PageInfo struct {
	HasNextPage     bool    `json:"hasNextPage"`
	HasPreviousPage bool    `json:"hasPreviousPage"`
	StartCursor     *string `json:"startCursor,omitempty"`
	EndCursor       *string `json:"endCursor,omitempty"`
}

type NotePreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance NotePreviousValuesExec) Exec(ctx context.Context) (*NotePreviousValues, error) {
	var v NotePreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance NotePreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type NotePreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance NotePreviousValuesExecArray) Exec(ctx context.Context) ([]NotePreviousValues, error) {
	var v []NotePreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type NotePreviousValues struct {
	ID    string `json:"id"`
	Title string `json:"title"`
	Body  string `json:"body"`
}

type NoteSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *NoteSubscriptionPayloadExec) Node() *NoteExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Note"},
		"node",
		[]string{"id", "title", "body"})

	return &NoteExec{ret}
}

func (instance *NoteSubscriptionPayloadExec) PreviousValues() *NotePreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "NotePreviousValues"},
		"previousValues",
		[]string{"id", "title", "body"})

	return &NotePreviousValuesExec{ret}
}

func (instance NoteSubscriptionPayloadExec) Exec(ctx context.Context) (*NoteSubscriptionPayload, error) {
	var v NoteSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance NoteSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type NoteSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance NoteSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]NoteSubscriptionPayload, error) {
	var v []NoteSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type NoteSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type NoteExec struct {
	exec *prisma.Exec
}

type TagsParamsExec struct {
	Where   *TagWhereInput
	OrderBy *TagOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *NoteExec) Tags(params *TagsParamsExec) *TagExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"TagWhereInput", "TagOrderByInput", "Tag"},
		"tags",
		[]string{"id", "title"})

	return &TagExecArray{ret}
}

func (instance NoteExec) Exec(ctx context.Context) (*Note, error) {
	var v Note
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance NoteExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type NoteExecArray struct {
	exec *prisma.Exec
}

func (instance NoteExecArray) Exec(ctx context.Context) ([]Note, error) {
	var v []Note
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Note struct {
	ID    string `json:"id"`
	Title string `json:"title"`
	Body  string `json:"body"`
}

type TagEdgeExec struct {
	exec *prisma.Exec
}

func (instance *TagEdgeExec) Node() *TagExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Tag"},
		"node",
		[]string{"id", "title"})

	return &TagExec{ret}
}

func (instance TagEdgeExec) Exec(ctx context.Context) (*TagEdge, error) {
	var v TagEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TagEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TagEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance TagEdgeExecArray) Exec(ctx context.Context) ([]TagEdge, error) {
	var v []TagEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type TagEdge struct {
	Cursor string `json:"cursor"`
}

type UserExec struct {
	exec *prisma.Exec
}

func (instance UserExec) Exec(ctx context.Context) (*User, error) {
	var v User
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserExecArray struct {
	exec *prisma.Exec
}

func (instance UserExecArray) Exec(ctx context.Context) ([]User, error) {
	var v []User
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type User struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

type UserConnectionExec struct {
	exec *prisma.Exec
}

func (instance *UserConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *UserConnectionExec) Edges() *UserEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "UserEdge"},
		"edges",
		[]string{"cursor"})

	return &UserEdgeExec{ret}
}

func (instance *UserConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateUser"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance UserConnectionExec) Exec(ctx context.Context) (*UserConnection, error) {
	var v UserConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance UserConnectionExecArray) Exec(ctx context.Context) ([]UserConnection, error) {
	var v []UserConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type UserConnection struct {
}
